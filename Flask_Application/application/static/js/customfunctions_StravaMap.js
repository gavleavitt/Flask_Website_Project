// Create Leafet search option using activity name
// This only searches active geoJSON data, without needing to be re-initialized, I am not sure why but it must automatically update when the layergroup its pointing to updates
function createSearchControl(layerGroup) {
  var searchControl = new L.Control.Search({
    layer:layerGroup,
    propertyName: 'name',
    zoom:15,
    marker:false,
    autoCollapse:true,
    initial:false,
    // set move to location to capture the full extend of the activity
    moveToLocation: function(latlng, OBJECTID, map) {
      var zoom = map.getBoundsZoom(latlng.layer.getBounds());
      map.setView(latlng, zoom);
    }
  });
  // Add control to map
  map.addControl(searchControl);
  searchControl.on('search:locationfound', function(e) {
    // Opens popup
    if(e.layer._popup)
      // Filter geoJSON to display only the searched feature
      searchedActivityOnly = showSearchResultOnly(e.layer.feature.properties.name);
      // Open popup for activity, for some reason I can't open the popup through just .openPopup here, so this method is used instead
      searchedActivityOnly.eachLayer(function(layer) {
        // Get the id of the layer within the layer group, this number is dynamically generated by Leaflet so has to be called using .keys() and extracted from the first index location, there will only ever be one layer within this feature group
        id = Object.keys(layer._layers)[0]
        // Bind the popup using the previously bond popup content
        layer.bindPopup(layer._layers[id]._popup._content);
        // Open the popup
        layer.openPopup();
      });
  });
  searchControl.on('search:expanded', function(e) {
    // Closes popups when user selects a new search
    map.closePopup()
    // Add active layers back to display and search options
    filteredGroup.clearLayers()
    addActiveLayers()
  });
}


// Set linestyles for each activity type
var mtb_lineStyle = {
  "color": "#e41a1c",
  "weight": 2,
  "opacity": 0.7,
  "fillColor": "black"
};
var road_lineStyle = {
  "color": "#377eb8",
  "weight": 2,
  "opacity": 0.7,
  "fillColor": "black"
};
var run_lineStyle = {
  "color": "#a65628",
  "weight": 2,
  "opacity": 0.7,
  "fillColor": "black"
};
var walk_lineStyle = {
    "color": "#984ea3",
    "weight": 2,
    "opacity": 0.7,
    "fillColor": "black"
};


// Style linestyles according to their properties, uses type_extended for rides since they are not differentiated in type property.
function actStyle(feature, layer) {
  if (feature.properties.type == "Walk") {
    return walk_lineStyle;
  } else if (feature.properties.type == "Run") {
    return run_lineStyle;
  } else if ((feature.properties.type == "Ride") && (feature.properties.type_extended == "Road Cycling")) {
    return road_lineStyle;
  } else if ((feature.properties.type == "Ride") && (feature.properties.type_extended == "Mountain Bike")) {
    return mtb_lineStyle;
  }
};

// Populate popups using property information, distances come from server in meters and are converted to feet/miles, link to public activites on Strava.
function onEachFeatureAct(feature,layer) {
  layer.bindPopup(
    "<div class='spanbotbord'><b>" + feature.properties.name + "</b></div>" +
      "<div><b>Type: " + feature.properties.type + "</b></div>" +
    "<div><b>Date (PST): " + feature.properties.startDate + "</b></div>" +
    "<div><b>Duration: " + convertDuration(feature.properties.elapsed_time) + "</b></div>" +
    "<div><b>Distance (Miles): " + (feature.properties.distance * 0.000621371).toFixed(1) + "</b></div>" +
    "<div><b>Elevation gain (Feet): " + (feature.properties.total_elevation_gain * 3.28084).toFixed(1) + "</b></div>" +
    "<div><b>Calories burned: " + feature.properties.calories + "</b></div>" +
    "<div><b>Average speed (mph): " + (feature.properties.average_speed * 2.23694).toFixed(1) + "</b></div>" +
    "<div><b>Activity ID: " + feature.properties.actID + "</b></div>" +
    privatecheck(feature.properties.private, feature.properties.actID)
  )
};


// Check if activity is flagged as private, if so say as such, otherwise create link to activity page on Strava
function privatecheck(privacy, actID) {
  if (privacy == "true"){
    res = "<div><b>Private Activity</b></div>"
  } else {
    res = "<div><b><a href=https://www.strava.com/activities/" + actID + ">Strava Activity Page</a></b></div>"
  }
  return res
};

// Duration is provided as seconds, convert to HH-MM-SS format
// I believe this effectively creates a datetime that's duration seconds since epoch, then extracts only HH-MM-SS seconds from that datetime
function convertDuration(seconds){
  // Create null date
  var date = new Date(null);
  // set date doing duration seconds
  date.setSeconds(seconds);
  // Extract HH-MMM-SS information
  var result = date.toISOString().substr(11, 8);
  return result
};

// If gearname is not null then the activity was a ride, return name of bike formatted with HTML
function geartext(gearname) {
  if (gearname){
    res = "<div><b>Bike: " + gearname + "</b></div>"
    return res
  }
};


// Un-used function to reset daterange picker to all activities (all-time)
function resetAll() {
  // $('#reportrange').data('daterangepicker').setStartDate(start);
  // $('#reportrange').data('daterangepicker').setEndDate(end);
  console.log("clicked reset button!")
  $('#reportrange').data('daterangepicker').setStartDate(start);
  $('#reportrange').data('daterangepicker').setEndDate(end);
  // $('#reportrange').updateView();
  console.log($('#reportrange').data('daterangepicker'))
};


// User has searched for a activity, hide all other activities
function showSearchResultOnly(activityName) {
  filteredGroup.clearLayers()
  filteredAct = L.geoJson(rawGeoJSON, {
      style: actStyle,
      onEachFeature: onEachFeatureAct,
      filter: function(feature, layer) {
        if (feature.properties.name == activityName) return true
      }
  });
  filteredGroup.addLayer(filteredAct);
  return filteredGroup
};


// Selects active buttons, excluding the "All" button, and interates over them rebuilding the associated geojson layers using the user selected dates.
// Start and end dates are set to null for initialization of the dataset.
// This function is called as a callback whenever the user changes the daterange selection or selects a activity filter button, maintaining previous date selections.
function addActiveLayers(userStartDate = null, userEndDate = null) {
  // If the "All" button is active, select all other activity buttons and set filters on all activities.
  if (document.getElementById('All').className.includes("active") == true) {
    active = document.querySelectorAll('.filterbtn:not(#All)');
    for (var h = 0; h < active.length; h++) {
      actFilter(active[h].id, userStartDate, userEndDate)
    }
  // "All" button is inactive, select all active buttons and filter their associated activity layers using user selected dates.
  } else {
    active = document.querySelectorAll('.active-btn:not(#All)');
    for (var h = 0; h < active.length; h++) {
      actFilter(active[h].id, userStartDate, userEndDate)
    }
  }
};

// Applies filters to displayed geoJSON based on activity button and/or daterange selections.
// Leaflet only applies filters when a geoJSON layer is initialized, these settings cannot be changed after a geoJSON layer is created.
// In order to apply filters on the fly, new geoJSON layers need to be re-initialized using the original un-aletered data (rawGeoJSON) with new filters in place.
function actFilter(actType, userStartDate = null, userEndDate = null){
  if ((userStartDate == null) && (userEndDate == null)) {
    // This function wasn't called by a change in the daterange selection. Use the default (includes all activities) or previously set daterange by selecting the displayed date range
    // and setting that as the filter range
    displayDate = document.getElementById("display-date").textContent.split(" - ");
    userStartDate = moment(new Date(displayDate[0])).format().slice(0,10)
    userEndDate = moment(new Date(displayDate[1])).format().slice(0,10)
  }
  if (actType=="All") {
    // User selected the "All" button, clear existing layers and replace with all activities within the date range
    filteredGroup.clearLayers()
  }
  // User selected an activity type or changed the daterange selection, create new geoJSON layer(s) with new filters in place that are based on on activity type and start and end dates
  filteredAct = L.geoJson(rawGeoJSON, {
      style: actStyle,
      onEachFeature: onEachFeatureAct,
			filter: function(feature, layer) {
        if (actType == "Walk") {
            if ((feature.properties.type == "Walk") && (feature.properties.startDate.slice(0,10) >=     userStartDate.slice(0,10)) && (feature.properties.startDate.slice(0,10) <= userEndDate.slice(0,10))) return true
        } else if (actType == "Run") {
            if ((feature.properties.type == "Run") && (feature.properties.startDate.slice(0,10) >= userStartDate.slice(0,10)) && (feature.properties.startDate.slice(0,10) <= userEndDate.slice(0,10))) return true
        } else if (actType == "MTB") {
            if ((feature.properties.type_extended == "Mountain Bike") && (feature.properties.startDate.slice(0,10) >= userStartDate.slice(0,10)) && (feature.properties.startDate.slice(0,10) <= userEndDate.slice(0,10)))
            return true
        } else if (actType == "Road") {
            if ((feature.properties.type_extended == "Road Cycling") && (feature.properties.startDate.slice(0,10) >= userStartDate.slice(0,10)) && (feature.properties.startDate.slice(0,10) <= userEndDate.slice(0,10)))
            return true
        } else if (actType == "All"){
            if (feature.properties.startDate.slice(0,10) >= userStartDate.slice(0,10) && (feature.properties.startDate.slice(0,10) <= userEndDate.slice(0,10))) return true
        }
			}
  });
  }
  // Add new layer to existing filtered group, which may be empty or contain additional geoJSON layers depending on user selections
  filteredGroup.addLayer(filteredAct);
};

// Button coloring and filter behavior, allows user to single and multi-select as well add and remove all
// layers with the "All" button.
// This function is loaded asynchronously after the document has loaded in the activity geojson data
function loadActivityListener() {
  // get div that contains the filter buttons
  var group = document.getElementById("act-filter-group");
  // get all buttons within group
  var btns = group.getElementsByClassName("filterbtn");
  // Iterate over buttons in group adding an click event listener to each
  for (var i = 0; i < btns.length; i++) {
    btns[i].addEventListener("click", function(obj) {
      //get active buttons, exluding the All button, this is used to determine if multi-selection is occurring
      active = document.querySelectorAll('.active-btn:not(#All)')
      // Check to see if button click target is the "All" button and if any other buttons are also flagged as active,
      // if so remove the active class from these buttons (reverting them to disabled opacity) and set the All button
      // to active and add all activity layers to display
      if ((obj.target.id == "All") && (active.length > 0)) {
        console.log("case A")
        // iterate over buttons flagged as active
        for (var h = 0; h < active.length; h++) {
          // remove active class from buttons, reverting them to disabled opacity
          active[h].className = active[h].className.replace(" active-btn", "");
        }
        // call function to add all activity layers to display
        actFilter("All")
        document.getElementById("All").innerHTML = "Remove<br>Layers";
        // set "All" button to active
        this.className += " active-btn";
        // change text of "All" to tell user that clicking it will remove all activity layers
        document.getElementById("All").innerHTML = "Remove<br>Layers";
      // Check if user click target is a button flagged as active
      } else if (obj.target.className.includes("active-btn")) {
        console.log("case B")
        // Remove active class from button, reverting it to the disabled opacity
        this.className = this.className.replace(" active-btn","");
        // If the target was the All button, clear all layers from display
        if (obj.target.id == "All"){
          // change text of "All" to tell user that clicking it will add all activity layers
          document.getElementById("All").innerHTML = "&nbsp;&nbsp;&nbsp;Add&nbsp;&nbsp;&nbsp;&nbsp;<br>Layers";
          filteredGroup.clearLayers()
        // if user clicks an active button that is not All, remove just that layer from display
        // A dictionary is used for lookup to select the correct layer using the target button's ID value
        } else {
          filteredGroup.clearLayers()
          // Add geojson data for all active buttons
          addActiveLayers()
          // document.getElementById("All").innerHTML = "Remove<br>Layers";
          // filteredGroup.removeLayer(layerGroupDict[obj.target.id]);
        }
      // Check if user click target is NOT the "All" button, but the "All" button is flagged as active
      // Used to determine if a user is selecting activity button when the "All" button is active
      } else if ((!(obj.target.id.includes("All"))) && (document.getElementById("All").className.includes("active-btn"))) {
          console.log("case C")
          // Remove the active flag from the "All" button, reverting to disabled opacity
          document.getElementById("All").className = document.getElementById("All").className.replace(" active-btn", "");
          // change text of "All" to tell user that clicking it will add all activity layers
          document.getElementById("All").innerHTML = "&nbsp;&nbsp;&nbsp;Add&nbsp;&nbsp;&nbsp;&nbsp;<br>Layers";
          // Set the target button to active
          this.className += " active-btn";
          // Remove all activity layers
          filteredGroup.clearLayers();
          // Add the activity layer associated with the button clicker by the user
          // console.log("Generating a new geojson!")
          actFilter(obj.target.id);
      // Last chase, user is multi-selecting activities, i.e. "All" is disabled and at least one other activity
      // is flagged as active
      } else if ((obj.target.id == "All") && (active.length == 0)) {
        console.log("case D")
        document.getElementById("All").innerHTML = "Add<br>Layers";
        this.className += " active-btn";
      } else {
        console.log("case E")
        // Set this activity to active, in addition to other active buttons
        this.className += " active-btn";
        // Add the layer associated with the button clicker by the user.
        // This is added in addition to other active layers
        // console.log("Multi-selecting!")
        actFilter(obj.target.id);
        // console.log(filteredGroup)
      }
    });
  }
};

function populateDashboard(geoJSONGroupLayer){
  geoJSONGroupLayer.eachLayer(function(layer){

  })

};
