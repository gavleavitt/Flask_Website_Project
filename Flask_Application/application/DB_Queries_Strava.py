from sqlalchemy import create_engine, or_
from sqlalchemy.orm import sessionmaker
# from settings import dbcon
from application.models_Strava import athletes, sub_update, strava_activities, strava_activities_masked, strava_gear
from application.models_tracker import AOI
import os
from datetime import datetime
from application import application, errorEmail, models_Strava
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import func as sqlfunc
import geojson
from geojson import Point, Feature, FeatureCollection, LineString

def createSession():
    engine = create_engine(os.environ.get("DBCON"))
    Session = sessionmaker(bind=engine)
    session = Session()
    return session


def updateSubId(subId):
    """
    Updates all athlete records with the new strava webhook subscription id.

    Method was taken from:
    https://stackoverflow.com/a/278606

    Parameters
    ----------
    subId: Integer. Provided by Strava following create subscription callback flow.

    Returns
    -------
    Nothing

    """
    session = createSession()
    try:
        session.query(athletes).update({athletes.sub_id: subId})
        session.commit()
        session.close()
    except Exception as e:
        application.logger.debug(f"Update Strava athlete sub Id failed with the exception: {e}")
        errorEmail.senderroremail(script="addtoGDrive", exceptiontype=e.__class__.__name__, body=e)

def getAthleteList():
    """
    Gets list of athlete IDs from database.

    Returns
    -------
    List. Athlete IDs (int) stored in database.
    """
    session = createSession()
    query = session.query(athletes).all()
    athleteList = []
    for i in query:
        athleteList.append(i.athlete_id)
    session.close()
    return athleteList

def getSubIdList():
    """
    Gets list of subscription webhook IDs from database.
    Returns
    -------
    List. Subscription webhook IDs (Int) stored in database.
    """
    session = createSession()
    query = session.query(athletes).all()
    subIdList = []
    for i in query:
        subIdList.append(i.sub_id)
    session.close()
    return subIdList

def insertSubUpdate(content):
    """

    Inserts Strava webhook subscription data into Postgres database. This information will be used to get full activity
    information from another query.

    Parameters
    ----------
    content. SubscriptionUpdate object of Strava webhook update generated by Stravalib

    Returns
    -------
    Nothing. Updates database.
    """
    # Verify is activity title is in update data, if not set to None.
    if "title" in content.updates.keys():
        title = content.updates['title']
        application.logger.debug(f"Title of new activity is {title}")
    else:
        title = None
    session = createSession()
    # print(content.event_time)
    # print(dir(content.event_time))
    # print(content.event_time.timestamp)
    insert = sub_update(aspect=content.aspect_type, event_time=datetime.fromtimestamp(content.event_time.timestamp), object_id=content.object_id,
                        object_type=content.object_type, owner_id=content.owner_id, subscription_id=content.subscription_id,
                        update_title = title)
    session.add(insert)
    session.commit()
    session.close()
    application.logger.debug(f"New webhook update has been added to Postgres!")

def insertAct(actDict):
    """
    Inserts new activity, POSTed by Strava webhook update or by manually triggering process activity event route.

    Parameters
    ----------
    actDict. Dict. Generated by StravaWebHook.handle_sub_update() or by getStravaActivities.processActs().

    Returns
    -------
    Nothing. Data are inserted into Postgres/PostGIS.
    """
    insert = strava_activities(actID=actDict['actId'], upload_id=actDict['upload_id'], name=actDict['name'],
                               distance=actDict['distance'], moving_time=actDict['moving_time'],
                               elapsed_time=actDict['elapsed_time'], total_elevation_gain=actDict['total_elevation_gain'],
                               elev_high=actDict['elev_high'], elev_low=actDict['elev_low'], type=actDict['type'],
                               start_date = actDict['start_date'], start_date_local=actDict['start_date_local'],
                               timezone = actDict['timezone'], utc_offset = actDict['utc_offset'],
                               start_latlng = actDict['start_latlng'], end_latlng = actDict['end_latlng'],
                               start_latitude = actDict['start_latitude'], start_longitude = actDict['start_longitude'],
                               achievement_count = actDict['achievement_count'], pr_count = actDict['pr_count'],
                               private = actDict['private'], gear_id = actDict['gear_id'],
                               average_speed = actDict['average_speed'], max_speed = actDict['max_speed'],
                               average_watts = actDict['average_watts'], kilojoules = actDict['kilojoules'],
                               description = actDict['description'], workout_type = actDict['workout_type'],
                               calories = actDict['calories'], device_name = actDict['device_name'],
                               manual = actDict['manual'], athlete_id=actDict['athlete_id'],
                               type_extended = actDict['type_extended'], geom = actDict['geom_wkt'])
    session = createSession()
    session.add(insert)
    session.commit()
    session.close()
    application.logger.debug(f"New webhook update for activity {actDict['actId']} has been added to Postgres!")

def getStravaMaskedActGeoJSON(actLimit):
    session = createSession()
    query = session.query(sqlfunc.ST_AsGeoJSON(strava_activities_masked.geom, 5).label("geom"),
                          strava_activities.name,
                          strava_activities.actID,
                          strava_activities.type,
                          strava_activities.distance,
                          strava_activities.private,
                          strava_activities.calories,
                          strava_activities.start_date,
                          strava_activities.elapsed_time,
                          strava_activities.start_date_local,
                          strava_activities.total_elevation_gain,
                          strava_activities.average_speed,
                          strava_activities.max_speed,
                          strava_activities.type_extended,
                          strava_gear.gear_name)\
        .join(strava_activities_masked.act_rel)\
        .join(strava_activities.gear_rel, isouter=True)\
        .order_by(strava_activities.start_date.desc())\
        .limit(actLimit)
    features = []
    print("Iterating over query!")
    for row in query:
        # Build a dictionary of the attribute information
        prop_dict = {"name": row.name, "actID": row.actID, "type": row.type, "distance": row.distance,
                     "private": row.private, "calories": row.calories, "startDate": row.start_date_local.isoformat(),
                     "elapsed_time": row.elapsed_time.seconds, "total_elevation_gain":row.total_elevation_gain,
                     "average_speed":row.average_speed,"max_speed":row.max_speed, "gear_name":row.gear_name,
                     "type_extended":row.type_extended}
        # Take ST_AsGeoJSON() result and load as geojson object
        # print(row[0])
        geojson_geom = geojson.loads(row[0])
        # geom = LineString(row_str)
        # geojson_geom = LineString(row[0])
        # Build the feature and add to feature list
        features.append(Feature(geometry=geojson_geom, properties=prop_dict))
    # Build the feature collection result
    feature_collection = FeatureCollection(features)
    # print(feature_collection)
    session.close()
    return feature_collection

def maskandInsertAct(actId):
    """

    Parameters
    ----------
    actId

    Returns
    -------

    """
    session = createSession()
    # Smoothing tolerence, in meters.
    smooth = 3
    # Projection srid to use for simplify, UTM 10N
    proj = 32610
    # Privacy geometries CTE
    private_aoi = session.query((AOI.geom).label("priv_aoi")).filter(AOI.privacy == "Yes").cte("privacy_aoi")

    # CTE query to query the geometry of new actID
    strava_geom = session.query((strava_activities.geom).label("trans_geom"),
                                (strava_activities.actID.label("strava_id"))).filter(
        strava_activities.actID == actId).cte("simp_cte")


    # Query first uses ST_Difference to split the linestrings by their intersections with the AOI polygons, I don't
    # entirely understand what this function does since it doesn't appear to follow the official description of
    # returning just geom B-A, it appears to return B-A and A. Next geom A is removed using a filter based on
    # ST_Intersects, which removes geom A, including areas with no intersection with geom B, I don't understand why
    # this combination of functions removes geom A that doesn't intersect geom B, however these data will be selected
    # again later.
    # Next the filtered data are transformed into UTM 10N (srid 32610) such that the data are in meters, not degrees,
    # and passed into ST_SimplifyPreserveTopology. This smooths data within the smoothing tolerance without breaking
    # any topology, the tolerance is in the geometry's units which makes more sense in meters. After smoothing the data
    # are transformed back into WGS 1984 (srid 4326) then returned as EWKT to be inserted into new table.
    maskedQuery = session.query(strava_geom.c.strava_id, sqlfunc.ST_AsEWKT(sqlfunc.ST_Multi(sqlfunc.ST_Transform(
        sqlfunc.ST_SimplifyPreserveTopology(
            sqlfunc.ST_Transform(sqlfunc.ST_Difference(strava_geom.c.trans_geom, private_aoi.c.priv_aoi), proj),
            smooth), 4326)))).filter(sqlfunc.ST_Intersects(strava_geom.c.trans_geom, private_aoi.c.priv_aoi))
    # Iterate over masked query result, add results to Postgres, should only ever be 1 empty at a time
    queryLen = 0
    for row in maskedQuery:
        insert = strava_activities_masked(actID=row[0], geom=row[1])
        # print(f"Activity ID {row[0]} had an intersections with a privacy AOI and has been added to the Postgres masked table!")
        session.add(insert)
        application.logger.debug(f"Activity ID {row[0]} had an intersection with a privacy AOI, masked linestring has been added to session")
        queryLen += 1
    # Check if masked query returned anything, if return is empty then the activity didn't intersect a privacy zone
    # Perform a separate query without ST_Difference or ST_Intersects
    if queryLen == 0:
        nonIntersectQuery = session.query(strava_activities.actID,
                                          sqlfunc.ST_AsEWKT(sqlfunc.ST_Multi(sqlfunc.ST_Transform(
                                              sqlfunc.ST_SimplifyPreserveTopology(
                                                  sqlfunc.ST_Transform(strava_activities.geom, proj), smooth),
                                              4326)))).filter(
            strava_activities.actID == actId)
        for row in nonIntersectQuery:
            insert = strava_activities_masked(actID=row[0], geom=row[1])
            session.add(insert)
            application.logger.debug(
                f"Activity ID {row[0]} had no intersections with a privacy AOI, linestring has been added to session")
    session.commit()
    session.close()
    application.logger.debug(
        f"Activity ID {actId} has been committed to Postgres")

def simplifyandMaskAllActivities():
    """


    Calculate difference, keep only different sections
    Do a separate query to select everything that didn't have an intersection with privacy areas.
    Use collect to combine these datasets
    create a new table with both datasets
    remain activity ID throughout the process to be used for joining attribute data
    Convert to UTM 10N 32610
    Returns
    -------
    """
    session = createSession()
    print("creating queries")
    # Smoothing tolerence, in meters.
    smooth = 3
    proj = 32610
    # get all act IDs from original database
    strava_IDs = session.query(strava_activities.actID)
    allID = []
    for i in strava_IDs:
        allID.append(i.actID)
    # print(f"Length of all query is: {len(allID)}")
    # Privacy geometries CTE
    private_aoi = session.query((AOI.geom).label("priv_aoi")).filter(AOI.privacy == "Yes").cte("privacy_aoi")

    # CTE query to query the geometries and act IDs of all records in original table
    strava_simp = session.query((strava_activities.geom).label("trans_geom"),
        (strava_activities.actID.label("strava_id"))).cte("simp_cte")

    # Query first uses ST_Difference to split the linestrings by their intersections with the AOI polygons, I don't
    # entirely understand what this function does since it doesn't appear to follow the official description of
    # returning just geom B-A, it appears to return B-A and A. Next geom A is removed using a filter based on
    # ST_Intersects, which removes geom A, including areas with no intersection with geom B, I don't understand why
    # this combination of functions removes geom A that doesn't intersect geom B, however these data will be selected
    # again later.
    # Next the filtered data are transformed into UTM 10N (srid 32610) such that the data are in meters, not degrees,
    # and passed into ST_SimplifyPreserveTopology. This smooths data within the smoothing tolerance without breaking
    # any topology, the tolerance is in the geometry's units which makes more sense in meters. After smoothing the data
    # are transformed back into WGS 1984 (srid 4326).
    # Activity IDs are also queried to keep track of which records were used in this process
    maskedQuery = session.query(strava_simp.c.strava_id,
                                sqlfunc.ST_AsEWKT(sqlfunc.ST_Multi(sqlfunc.ST_Transform(sqlfunc.ST_SimplifyPreserveTopology(sqlfunc.ST_Transform(sqlfunc.ST_Difference(
            strava_simp.c.trans_geom, private_aoi.c.priv_aoi),proj),smooth),4326))))\
        .filter(sqlfunc.ST_Intersects(strava_simp.c.trans_geom, private_aoi.c.priv_aoi))

    allFeatures = []
    differenceIds = []
    print("Working on masked query")
    for row in maskedQuery:
        # print(f"working on {row[0]}")
        differenceIds.append(row.strava_id)
        allFeatures.append([row[0], row[1]])
        # geojson_geom = geojson.loads(row[1])
        # features.append(Feature(geometry=geojson_geom))
    # print(f"Len of differenceIDs list is {len(differenceIds)}")
    # print(differenceIds)
    nonIntersectqueryList = list(set(allID)-set(differenceIds))
    # print(f"Length of non-intersecting list is {len(nonIntersectqueryList)}")
    # print(nonIntersectqueryList)
    # print(queryList)
    # print(f"Length of all feature list with only intersecting linestrings is {len(allFeatures)}")
    # Query geoms in nonIntersectqueryList
    print("Finished masked query, working on non-intersect query")
    nonIntersectQuery = session.query(strava_activities.actID, sqlfunc.ST_AsEWKT(sqlfunc.ST_Multi(sqlfunc.ST_Transform(
        sqlfunc.ST_SimplifyPreserveTopology(sqlfunc.ST_Transform(strava_activities.geom, proj), smooth), 4326)))).filter(
        strava_activities.actID.in_(nonIntersectqueryList))
    # print(nonIntersectQuery)
    for row in nonIntersectQuery:
        # print(f"working on non-intersecting actID {row[0]}")
        # differenceIds.append(row.strava_id)
        allFeatures.append([row[0], row[1]])

    # print(f"Length of all feature list with all linestrings added is {len(allFeatures)}")
    print("Non-intersect query complete, adding all features to session")
    for item in allFeatures:
        # print(type(item[1]))
        # print(len(item[1]))
        # print(item[1])
        # print(f"working on {item[0]}")
        insert = strava_activities_masked(actID=item[0], geom=item[1])
        session.add(insert)
        # print(f"Activity {item[0]} has been added to session!")
    print("All sessions added, committing!")
    session.commit()
    session.close()
    print("All entries committed to database!")
    # feature_collection = FeatureCollection(features)
    # return feature_collection