from sqlalchemy import create_engine, or_
from sqlalchemy.orm import sessionmaker
# from settings import dbcon
from application.models_Strava import athletes, sub_update, strava_activities
from application.models import AOI
import os
from datetime import datetime
from application import application, errorEmail
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import func as sqlfunc
import geojson
from geojson import Point, Feature, FeatureCollection, LineString

engine = create_engine(os.environ.get("DBCON"))
Session = sessionmaker(bind=engine)
session = Session()


def createTable(tableModel):
    Base = declarative_base()
    tableObjects = [tableModel.__table__]
    Base.metadata.create_all(engine, tables=tableObjects)

def updateSubId(subId):
    """
    Updates all athlete records with the new strava webhook subscription id.

    Method was taken from:
    https://stackoverflow.com/a/278606

    Parameters
    ----------
    subId: Integer. Provided by Strava following create subscription callback flow.

    Returns
    -------
    Nothing

    """

    try:
        session.query(athletes).update({athletes.sub_id: subId})
        session.commit()
    except Exception as e:
        application.logger.debug(f"Update Strava athlete sub Id failed with the exception: {e}")
        errorEmail.senderroremail(script="addtoGDrive", exceptiontype=e.__class__.__name__, body=e)

def getAthleteList():
    """
    Gets list of athlete IDs from database.

    Returns
    -------
    List. Athlete IDs (int) stored in database.
    """
    query = session.query(athletes).all()
    athleteList = []
    for i in query:
        athleteList.append(i.athlete_id)
    return athleteList

def getSubIdList():
    """
    Gets list of subscription webhook IDs from database.
    Returns
    -------
    List. Subscription webhook IDs (Int) stored in database.
    """
    query = session.query(athletes).all()
    subIdList = []
    for i in query:
        subIdList.append(i.sub_id)
    return subIdList

def insertSubUpdate(content):
    """

    Inserts Strava webhook subscription data into Postgres database. This information will be used to get full activity
    information from another query.

    Parameters
    ----------
    content. SubscriptionUpdate object of Strava webhook update generated by Stravalib

    Returns
    -------
    Nothing. Updates database.
    """
    # Verify is activity title is in update data, if not set to None.
    if "title" in content.updates.keys():
        title = content.updates['title']
        application.logger.debug(f"Title of new activity is {title}")
    else:
        title = None
    insert = sub_update(aspect=content.aspect, event_time=content.event_time, object_id=content.object_id,
                        object_type=content.object_type, owner_id=content.owner_id, subscription_id=content.subscription_id,
                        update_title = title)
    session.add(insert)
    session.commit()
    application.logger.debug(f"New webhook update has been added to Postgres!")

def insertAct(actDict):
    """
    Inserts new activity, POSTed by Strava webhook update or by manually triggering process activity event route.

    Parameters
    ----------
    actDict. Dict. Generated by StravaWebHook.handle_sub_update() or by getStravaActivities.processActs().

    Returns
    -------
    Nothing. Data are inserted into Postgres/PostGIS.
    """
    insert = strava_activities(actID=actDict['actId'], upload_id=actDict['upload_id'], name=actDict['name'],
                               distance=actDict['distance'], moving_time=actDict['moving_time'],
                               elapsed_time=actDict['elapsed_time'], total_elevation_gain=actDict['total_elevation_gain'],
                               elev_high=actDict['elev_high'], elev_low=actDict['elev_low'], type=actDict['type'],
                               start_date = actDict['start_date'], start_date_local=actDict['start_date_local'],
                               timezone = actDict['timezone'], utc_offset = actDict['utc_offset'],
                               start_latlng = actDict['start_latlng'], end_latlng = actDict['end_latlng'],
                               start_latitude = actDict['start_latitude'], start_longitude = actDict['start_longitude'],
                               achievement_count = actDict['achievement_count'], pr_count = actDict['pr_count'],
                               private = actDict['private'], gear_id = actDict['gear_id'],
                               average_speed = actDict['average_speed'], max_speed = actDict['max_speed'],
                               average_watts = actDict['average_watts'], kilojoules = actDict['kilojoules'],
                               description = actDict['description'], workout_type = actDict['workout_type'],
                               calories = actDict['calories'], geom = actDict['geom_wkt'])
    session.add(insert)
    session.commit()
    application.logger.debug(f"New webhook update for activity {actDict['actId']} has been added to Postgres!")

# def getStravaActGeoJSON(actLimit):
#
#     private_aoi = session.query(AOI.geom).filter(AOI.privacy=="Yes").as_scalar()
#     query = session.query(sqlfunc.ST_Difference(strava_activities.geom, private_aoi))
#                           #                       ()),
#                           # strava_activities).order_by(strava_activities.id.desc()).limit(actLimit)
#     # use https://postgis.net/docs/ST_Difference.html
#     # query = session.query(sqlfunc.ST_AsGeoJSON(strava_activities.geom),
#     #                       strava_activities).order_by(strava_activities.id.desc()).limit(actLimit)
#     features = []
#     for row in query:
#         # Build a dictionary of the attribute information
#         prop_dict = row[1].builddict()
#         # Take ST_AsGeoJSON() result and load as geojson object
#         geojson_geom = geojson.loads(row[0])
#         # print(row[0])
#         # geojson_geom = LineString(row[0])
#         # Build the feature and add to feature list
#         features.append(Feature(geometry=geojson_geom, properties=prop_dict))
#     # Build the feature collection result
#     feature_collection = FeatureCollection(features)
#     # print(feature_collection)
#     print("Feature collection generated!")
#     return feature_collection
